# Promise 方法

**`Promise` 中的执行函数是同步进行的**，但是里面存在着异步操作，**在异步操作结束后会调用 `resolve` 方法**，或者中途遇到错误调用 `reject` 方法，这两者都是作为微任务进入到 `EventLoop` 中。

下面的例子，来了解同步和异步

```js
console.log(1)
let promiseDemo = new Promise((resolve, reject) => {
    console.log(2)
    let random = Math.random()
    if (random >= 0.2) {
        resolve('success')
        console.log(3)
    } else {
        reject('failed')
        console.log(3)
    }   
})
console.log(8)
async function test() {
    console.log(4)
    let result = await promiseDemo
    return result
}
setTimeout(() => {
    console.log(7)
}, 0)
test().then(result => {
    console.log(5)
}).catch((result) => {
    console.log(5)
})

console.log(6)

// 1 2 3 8 4 6 7 5
```

## then()
用于成功时的回调函数。


## catch()
用于指定发生错误时的回调函数。

一般来说，不要在`then()`方法里面定义 `Reject` 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。

```js
// bad
promise
    .then(function(data) {
        // success
    }, function(err) {
        // error
    });

// good
promise
    .then(function(data) {
        // success
    })
    .catch(function(err) {
        // error
    });
```

## finally()

`finally()`方法用于指定不管`Promise`对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。

`finally`方法的回调函数不接受任何参数，方法里面的操作，是与状态无关的，不依赖于`Promise`的执行结果。

```js
promise
    .then(result => {···})
    .catch(error => {···})
    .finally(() => {···});

promise
    .finally(() => {
    // 语句
    });

// 等同于
promise
    .then(
        result => {
            // 语句
            return result;
        },
        error => {
            // 语句
            throw error;
        }
    );
```
上面代码中，如果不使用`finally`方法，同样的语句需要为成功和失败两种情况各写一次。有了`finally`方法，则只需要写一次。



## Promise.all()

方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。

只有`Promise1`、`Promise2`、`Promise3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`Promise1`、`Promise2`、`Promise3`的返回值组成一个数组，传递给`p`的回调函数。

只要`Promise1`、`Promise2`、`Promise3`之中**有一个被`rejected`**，p的状态才会变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

```js
let Promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        var num = Math.ceil(Math.random()*10); //生成1-10的随机数
        if(num <= 5){
            resolve(num);
        }
        else{
            reject('数字太大了');
        }
    }, 2000)
})
let Promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        var num = Math.ceil(Math.random()*10); //生成1-10的随机数
        if(num <= 5){
            resolve(num);
        }
        else{
            reject('数字太大了');
        }
    }, 2000)
})
let Promise3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        var num = Math.ceil(Math.random()*10); //生成1-10的随机数
        if(num <= 5){
            resolve(num);
        }
        else{
            reject('数字太大了');
        }
    }, 2000)
})

let p = Promise.all([Promise1, Promise2, Promise3])

p.then((res) => {
    // 三个都成功则成功  
    console.log('resolved', res)
}).catch((err) => {
    // 只要有失败，则失败 
    console.log('rejectd', err)
})
```

适合使用的场景，在所有异步方法都执行完毕后，再执行某一方法。

## Promise.race()

`requestImg`函数会异步请求一张图片，我把地址写为"图片的路径"，所以肯定是无法成功请求到的。

`timeout`函数是一个延时5秒的异步操作。我们把这两个返回`Promise`对象的函数放进`race`，于是他俩就会赛跑

如果5秒之内图片请求成功了，那么遍进入`then`方法，执行正常的流程。如果5秒钟图片还未成功返回，那么`timeout`就跑赢了，则进入`catch`，报出“图片请求超时”的信息。

如果指定时间内没有获得结果，就将 `Promise` 的状态变为`reject`，否则变为`resolve`。

```js
//请求某个图片资源
function requestImg(){
    var p = new Promise((resolve, reject) => {
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = '图片的路径';
    });
    return p;
}
//延时函数，用于给请求计时
function timeout(){
    var p = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}
Promise.race([requestImg(), timeout()]).then((data) =>{
    console.log(data);
}).catch((err) => {
    console.log(err);
});
```

## Promise.allSettled()

接受一组 `Promise` 实例作为参数，包装成一个新的`Promise`实例。只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束。该方法由 ES2020 引入。

该方法返回的新的`Promise`实例，一旦结束，状态总是`fulfilled`，不会变成`rejected`。

状态变成`fulfilled`后，`Promise`的监听函数接收到的参数是一个数组，每个成员对应一个传入`Promise.allSettled()`的`Promise`实例。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then((results) => {
  console.log(results);  
});
// [{status: "fulfilled", value: 42}, {status: "rejected", reason: -1}]
```