# toString & valueOf

基本上，所有JS数据类型都拥有这两个方法，null除外。它们俩是位于原型链上的方法，也是为了解决javascript值运算与显示的问题。

`valueOf` 和 `toString` 几乎都是在出现操作符`(+-*/==><)`时被调用（隐式转换）。

## toString

> 返回一个表示该对象的字符串，当对象表示为文本值或以期望的字符串方式被引用时，toString方法被自动调用。


1. 手动调用看看什么效果

嗯，跟介绍的一样，没骗人，全部都转成了字符串。

```js
let a = {}
let b = [1, 2, 3]
let c = '123'
let d = function(){ console.log('fn') }

console.log(a.toString())   // '[object Object]'
console.log(b.toString())   // '1,2,3'
console.log(c.toString())   // '123'
console.log(d.toString())   // 'function(){ console.log('fn') }'
```

2. 判断类型

这种属于更精确的判断方式，在某种场合会比使用 `typeof` & `instanceof` 来的更高效和准确些。

```js
toString.call(()=>{})       // [object Function]
toString.call({})           // [object Object]
toString.call([])           // [object Array]
toString.call('')           // [object String]
toString.call(22)           // [object Number]
toString.call(undefined)    // [object undefined]
toString.call(null)         // [object null]
toString.call(new Date)     // [object Date]
toString.call(Math)         // [object Math]
toString.call(window)       // [object Window]
```

3. 自动调用

使用操作符的时候，如果其中一边为对象，则会先调用`toSting`方法，也就是`隐式类型转换`，然后再进行操作。

```js
let c = [1, 2, 3]
let d = {a:2}
Object.prototype.toString = function(){
    console.log('Object')
}
Array.prototype.toString = function(){
    console.log('Array')
}
Number.prototype.toString = function(){
    console.log('Number')
}
String.prototype.toString = function(){
    console.log('String')
}
console.log(2 + 1)  // 3
console.log('s')    // 's'
console.log('s'+2)  // 's2'
console.log(c < 2)  // false        (一次 => 'Array')
console.log(c + c)  // "1,2,31,2,3" (两次 => 'Array')
console.log(d > d)  // false        (两次 => 'Object')
```

4. 重写`toString`方法

```js
class A {
    constructor(count) {
        this.count = count
    }
    toString() {
        return '我有这么多钱：' + this.count
    }
}
let a = new A(100)

console.log(a)              // A {count: 100}
console.log(a.toString())   // 我有这么多钱：100
console.log(a + 1)          // 我有这么多钱：1001
```

## valueOf

> 返回当前对象的原始值。

具体功能与`toString`大同小异，同样具有以上的自动调用和重写方法。

这里就没什么好说的了，主要为两者间的区别，有请往下看🙊🙊

```js
let c = [1, 2, 3]
let d = {a:2}

console.log(c.valueOf())    // [1, 2, 3]
console.log(d.valueOf())    // {a:2}
```

## 两者区别

- 共同点：在输出对象时会自动调用。
- 不同点：存在优先级关系。

二者并存的情况下，在**数值**运算中，优先调用了`valueOf`，**字符串**运算中，优先调用了`toString`。

看代码方可知晓：

```js
class A {
    valueOf() {
        return 2
    }
    toString() {
        return '哈哈哈'
    }
}
let a = new A()

console.log(String(a))  // '哈哈哈'   => (toString)
console.log(Number(a))  // 2         => (valueOf)
console.log(a + '22')   // '222'     => (valueOf)
console.log(a == 2)     // true      => (valueOf)
console.log(a === 2)    // false
```

结果给人的感觉是，如果转换为字符串时调用toString方法，如果是转换为数值时则调用valueOf方法，但其中有两个很不和谐。一个是alert(''+bbb)，字符串合拼应该是调用toString方法……另一个我们暂时可以理解为===操作符不进行隐式转换，因此不调用它们。为了追究真相，我们需要更严谨的实验。


## 面试题

1. [大厂面试题分享：如何让(a===1&&a===2&&a===3)的值为true?](https://juejin.im/post/6844904085930377229)

来自腾讯大佬的分享，借以学习

双等号(==)：会触发`隐式类型转换`，所以可以使用 `valueOf` 或者 `toString` 来实现。

```js
class A {
    constructor(value) {
        this.value = value;
    }
    valueOf() {
        return this.value++;
    }
}
const a = new A(1);
if (a == 1 && a == 2 && a == 3) {
    console.log("Hi Libai!");
}
```

全等(===)：严格等于不会进行`隐式转换`，这里使用 `Object.defineProperty` 数据劫持的方法来实现

```js
let value = 1;
Object.defineProperty(window, 'a', {
    get() {
        return value++
    }
})
if (a === 1 && a === 2 && a === 3) {
    console.log("Hi Libai!")
}
```

上面我们就是劫持全局`window`上面的`a`，当`a`每一次做判断的时候都会触发`get`属性获取值，并且每一次获取值都会触发一次函数实行一次自增，判断三次就自增三次，所以最后会让公式成立。

注：`defineProperty` 可参考这篇文章学习，[点我进入传送门](https://github.com/wsydxiangwang/Note/blob/master/docs/web/Object/5.md)

2. 